<?phpnamespace parsersPicksgrail\helpers;class ProxyHelper{    protected $config;    protected $domain;    protected $attempts = 10;    public function __construct($config, $domain)    {        $this->config = $config;        $this->domain = $domain;    }    public function getProxy($cookies, $headers, $domain)    {        for ($i = 0; $i < $this->attempts; $i++) {            //берем 1 случайный прокси с файла            $proxy = $this->getOneProxyFromList();            //проверяем его на работоспособность            $result = $this->checkProxy($proxy, $cookies, $headers, $domain);            //если рабочий, то берем его            if ($result === true) {                return $proxy;            }            //если в списке все прокси не рабочие, заменить на новые            if ($i === 9) {                //получение новых прокси                $arrayNewProxy = file_get_contents($this->config["proxy_path_in_service"]);                //если все прокси с сервиса не работают                if (!$arrayNewProxy) { break; }                //перезапись в файле                $f = fopen($this->config['proxy_file'],'w');                fwrite($f, $arrayNewProxy);                fclose($f);                //начинаем цикл заново                $i = 0;            }        }        echo "haven't work proxy in the service!\n";        return false;    }    protected function getOneProxyFromList()    {        //получение списка прокси        $arrayProxies = file($this->config['proxy_file']);        //чистка и получаем случайный прокси из списка        $cleanOneProxy = trim($arrayProxies[rand(0, (count($arrayProxies)) - 1)]);        return $cleanOneProxy;    }    public function checkProxy($proxy, $cookies, $headers, $domain)    {        $ch = curl_init('http://sergeyshein.ru/');        curl_setopt($ch, CURLOPT_PROXY, $proxy);        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);        $response = curl_exec($ch);        //получаем код ответа сервера        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);        curl_close($ch);        if ($httpCode === 200) {            return true;        } else {            return false;        }    }    public function getHtmlContentFromUrlWithProxy($parseUrl, $cookies, $headers, $domain)    {        return '';        /*        $ch = curl_init($parseUrl);        curl_setopt($ch, CURLOPT_HEADER, false);        //получение одного прокси        $proxyArray = $this->getProxy($cookies, $headers, $domain);        $proxy = '';        //>проверки на добавление других настроек        if ($proxyArray !== false) {            $proxy = implode(':', $proxyArray);            curl_setopt($ch, CURLOPT_PROXY, $proxyArray[0]);            curl_setopt($ch, CURLOPT_PROXYPORT, $proxyArray[1]);        }        //для всех досок, кроме olx будут использоваться эти настройки        if ($domain !== 'olx.by') {            curl_setopt($ch, CURLOPT_COOKIEJAR, $cookies);            curl_setopt($ch, CURLOPT_COOKIEFILE, $cookies);        }        //>если есть логин и пароль к прокси// не предусматривать эту проверку        if (!empty($this->login) && !empty($this->password) && $this->proxyType === 'CURLPROXY_SOCKS5') {            $loginWithPassword = $this->login . ":" . $this->password;            curl_setopt($ch, CURLOPT_PROXYUSERPWD, $loginWithPassword);        }        //<        curl_setopt($ch, CURLOPT_PROXYTYPE, $this->proxyType);        curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 15);        curl_setopt($ch, CURLOPT_TIMEOUT, 15);        curl_setopt($ch, CURLOPT_URL, $parseUrl);        $html = curl_exec($ch);        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);        curl_close($ch);        echo "Response from server - " . $httpCode . ", from proxy - " . $proxy . ".\n";        //формирование ответа        if ($httpCode === 301 || $httpCode === 302) {            echo "A redirect has occurred!\n";            return false;        } elseif ($httpCode === 404) {            return false;        } else {            //проверка кодировки и последующий возврат html            return $this->checkHelper->checkEncoding($html, $domain);        }        */    }}