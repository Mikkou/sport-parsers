<?phpnamespace parsersPicksgrail\helpers;class ProxyHelper{    protected $config;    protected $domain;    protected $attempts = 10;    public function __construct($config, $domain)    {        $this->config = $config;        $this->domain = $domain;    }    public function getProxy($cookies, $headers, $domain)    {        for ($i = 0; $i < $this->attempts; $i++) {            //берем 1 случайный прокси с файла            $proxy = $this->getOneProxyFromList();            //проверяем его на работоспособность            $result = $this->checkProxy($proxy, $cookies, $headers, $domain);            //если рабочий, то берем его            if ($result === true) {                return $proxy;            }            //если в списке все прокси не рабочие, заменить на новые            if ($i === 9) {                //получение новых прокси                $arrayNewProxy = file_get_contents($this->config["proxy_path_in_service"]);                //если все прокси с сервиса не работают                if (!$arrayNewProxy) { break; }                //перезапись в файле                $f = fopen($this->config['proxy_file'],'w');                fwrite($f, $arrayNewProxy);                fclose($f);                //начинаем цикл заново                $i = 0;            }        }        echo "haven't work proxy in the service!\n";        return false;    }    public function getOneProxyFromList()    {        //получение списка прокси        $arrayProxies = file($this->config['proxy_file']);        //чистка и получаем случайный прокси из списка        $cleanOneProxy = trim($arrayProxies[rand(0, (count($arrayProxies)) - 1)]);        return $cleanOneProxy;    }    public function checkProxy($proxy, $cookies, $headers, $domain)    {        $ch = curl_init('http://sergeyshein.ru/');        curl_setopt($ch, CURLOPT_PROXY, $proxy);        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);        $response = curl_exec($ch);        //получаем код ответа сервера        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);        curl_close($ch);        if ($httpCode === 200) {            return true;        } else {            return false;        }    }    public function getHtmlContentFromUrlWithProxy($parseUrl, $cookies, $headers, $domain)    {        $attempts = $this->getAttempts();        // here we try to get the html with work proxy        for ($i = 0; $i < $attempts; $i++) {            // get random proxy from list            $proxy = $this->getOneProxyFromList();            $ch = curl_init($parseUrl);            if ($domain === 'oddsportal.com') {                curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:49.0) Gecko/20100101 Firefox/49.0');            }            curl_setopt($ch, CURLOPT_HEADER, 0);            curl_setopt($ch, CURLOPT_PROXY, $proxy);            curl_setopt($ch, CURLOPT_COOKIEJAR, $cookies);            curl_setopt($ch, CURLOPT_COOKIEFILE, $cookies);            curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);            curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);            curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);            curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 15);            curl_setopt($ch, CURLOPT_TIMEOUT, 15);            curl_setopt($ch, CURLOPT_URL, $parseUrl);            $html = curl_exec($ch);            $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);            curl_close($ch);            echo "Response from server - " . $httpCode . ", from proxy - " . $proxy . ".\n";            // return response            if ($httpCode === 301 || $httpCode === 302) {                echo "A redirect has occurred!\n";                return false;            } elseif ($httpCode === 200) {                return $html;            } else {                // if in list all proxies don't work, replace on new                if ($i === 9) {                    echo "refresh proxy list \n";                    // get new proxies                    $arrayNewProxy = file_get_contents($this->config["proxy_path_in_service"]);                    // if all proxies don't work                    if (!$arrayNewProxy) { break; }                    // rewrite in file                    $f = fopen($this->config['proxy_file'],'w');                    fwrite($f, $arrayNewProxy);                    fclose($f);                    // begin cycle first                    $i = 0;                }                continue;            }        }    }    public function getAttempts() {        return $this->attempts;    }}